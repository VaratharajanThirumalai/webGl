<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Cube-Plane Collision</title>
  <style>
    body {
      margin: 0;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="webgl-canvas" width="1800" height="800"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
  <script>
    const canvas = document.getElementById('webgl-canvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
      console.error('Unable to initialize WebGL. Your browser may not support it.');
    }

    const vertexShaderSource = `
      attribute vec4 a_position;
      uniform mat4 u_modelMatrix;
      uniform mat4 u_ViewMatrix;
      uniform mat4 u_projectionMatrix;
      void main() {
        gl_Position = u_projectionMatrix * u_ViewMatrix *  u_modelMatrix * a_position;
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      uniform vec4 u_color;
      void main() {
        gl_FragColor = u_color;
      }
    `;

    function compileShader(gl, source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      return program;
    }

    const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

    if (!vertexShader || !fragmentShader) {
      console.error('Error compiling shaders.');
    }

    const program = createProgram(gl, vertexShader, fragmentShader);

    if (!program) {
      console.error('Error creating program.');
    }

    const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
    const modelMatrixLocation = gl.getUniformLocation(program, 'u_modelMatrix');
    const ViewMatrixLocation = gl.getUniformLocation(program, 'u_ViewMatrix');
    const projectionMatrixLocation = gl.getUniformLocation(program, 'u_projectionMatrix');
    const colorLocation = gl.getUniformLocation(program, 'u_color');

    const vertices = new Float32Array([
      -0.5, -0.5, -0.5,
      0.5, -0.5, -0.5,
      0.5, 0.5, -0.5,
      -0.5, 0.5, -0.5,
      -0.5, -0.5, 0.5,
      0.5, -0.5, 0.5,
      0.5, 0.5, 0.5,
      -0.5, 0.5, 0.5,
    ]);

    const planeVertices = new Float32Array([
      -5, 0, -5,
      5, 0, -5,
      5, 0, 5,
      -5, 0, 5,
    ]);

    const indices = new Uint16Array([
      0, 1, 2, 0, 2, 3,
      4, 5, 6, 4, 6, 7,
      0, 3, 7, 0, 7, 4,
      1, 2, 6, 1, 6, 5,
      2, 3, 7, 2, 7, 6,
      0, 1, 5, 0, 5, 4,
    ]);

    const planeIndices = new Uint16Array([
      0, 1, 2, 0, 2, 3,
      3, 2, 1, 3, 1, 0,  // Duplicate vertices to form quads
    ]);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const planeVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, planeVertices, gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    const planeIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeIndices, gl.STATIC_DRAW);

    gl.useProgram(program);
    gl.enableVertexAttribArray(positionAttributeLocation);

    let planePosition = 0;
    let cubespeed = 0.05;
    let cubePosition = 5;
    let planeHalfSize = [5, 0, 5];

    function checkCollision(center1, halfSize1, center2, halfSize2) {
      const dx = Math.abs(center1[0] - center2[0]);
      const dy = Math.abs(center1[1] - center2[1]);
      const dz = Math.abs(center1[2] - center2[2]);

      const halfSizeSumX = halfSize1[0] + halfSize2[0];
      const halfSizeSumY = halfSize1[1] + halfSize2[1];
      const halfSizeSumZ = halfSize1[2] + halfSize2[2];

      return (
        dx <= halfSizeSumX &&
        dy <= halfSizeSumY &&
        dz <= halfSizeSumZ
      );
    }

    function render() {
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);
      cubePosition += cubespeed;
      if (cubePosition > 5 || cubePosition < -5) {
        cubespeed = -cubespeed;
      }
      const eye = [0, 5, 20];
      const center = [0, 0, 0];
      const up = [0, 1, 0];
      const projectionMatrix = mat4.create();
      const ViewMatrix = mat4.create();
      const modelMatrix = mat4.create();
      mat4.lookAt(ViewMatrix, eye, center, up);
      mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 1, 100);
      gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
      gl.uniformMatrix4fv(ViewMatrixLocation, false, ViewMatrix);
      gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
      gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexBuffer);
      gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);
      gl.uniform4fv(colorLocation, [1, 1, 1, 0]);
      mat4.translate(modelMatrix, modelMatrix, [0, planePosition, 0]);
      gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
      gl.drawElements(gl.LINE_LOOP, 6, gl.UNSIGNED_SHORT, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

      const cubeCenter = [0, cubePosition, 0];
      const cubeHalfSize = [0.5, 0.5, 0.5];
      const isCollision = checkCollision(cubeCenter, cubeHalfSize, [0, planePosition, 0], planeHalfSize);

      if (isCollision) {
        console.log("Collision detected!");
        mat4.identity(modelMatrix);
        gl.uniform4fv(colorLocation, [1, 0, 0, 1]);
        mat4.translate(modelMatrix, modelMatrix, [0, cubePosition, 0]);
        gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
      } else {
        gl.uniform4fv(colorLocation, [0, 1, 1, 1]);
        mat4.identity(modelMatrix);
        mat4.translate(modelMatrix, modelMatrix, [0, cubePosition, 0]);
        gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
      }

      requestAnimationFrame(render);
    }

    render();
  </script>
</body>

</html>
